---
title: "data"
author: "Jasmine Toh"
date: "11/4/2020"
output: html_document
---


Setup:
```{r setup, include<-FALSE}
knitr::opts_chunk$set(echo <- TRUE)
```

```{r}
# R Packages
packages = c('shiny', 
             'shinydashboard', 
             'shinyWidgets', 
             'DT', 
             'leaflet',
             'tidyverse',
             'knitr',
             'stringr',
             'httr',
             'geojsonio', 
             'sp', 
             'dplyr', 
             'SpatialAcc', 
             'rgeos', 
             'spdplyr', 
             'KernSmooth', 
             'raster',
             'reshape2', 
             'sf',
             'rgdal',
             'spdep',
             'tmap'
             ) 

for (p in packages){
  if(!require(p, character.only = T)){ 
    install.packages(p)
  }
  library(p,character.only = T) 
}

memory.limit(size=56000)


# Data Paths

dp_g = "../data/geospatial" 
dp_a_prefix = "../data/aspatial/" 
dp_j_prefix = "../data/geojson/" 
dp_m_prefix = "../data/distancematrix/" 
dp_h_prefix = "../data/hansen/" 
dp_s_prefix = "../data/sam/" 

dp_a_jc = paste(dp_a_prefix, "jc.csv", sep="")
dp_a_hdb = paste(dp_a_prefix, "hdb-property-information.csv", sep="")
dp_a_zip = paste(dp_a_prefix, "sg_zipcode_mapper.csv", sep="")


# Data variables

jc_data <- read.csv(dp_a_jc)
hdb_data <- read.csv(dp_a_hdb)
zip_data <- read.csv(dp_a_zip)

# Data Wrangling

## Select

jc_data$POSTAL <- as.numeric(jc_data$POSTAL)
jc <- jc_data%>% 
  dplyr::select("SCHOOL"='SEARCHVAL', 'POSTAL', 'LATITUDE', 'LONGITUDE', 'X', 'Y', 'ROAD_NAME')

hdb <- zip_data%>%
  dplyr::select('ADDRESS' = 'address', 'POSTAL'="postal", 'LATITUDE' = 'latitude', 'LONGITUDE' = 'longtitude', 'ROAD_NAME' = 'road_name')


## CRS

crsobj = CRS("+init=EPSG:3414")
coordinates(jc)<-~LONGITUDE+LATITUDE
proj4string(jc) = crsobj

coordinates(hdb)<-~LONGITUDE+LATITUDE
proj4string(hdb) = crsobj
```


# Isochrone generation for all JC 

function to get geojson
```{r}
library(httr)
get_geojson<-function(lat,lng,filename){

current <- GET(
  "http://localhost:8080/otp/routers/current/isochrone",
  query = list(
    fromPlace = paste(lat,lng,sep = ","), # latlong of place
    mode = "WALK,TRANSIT", # modes we want the route planner to use
    date = "05-11-2020",
    time= "07:00am",
    maxWalkDistance = 1600, # in metres
    walkReluctance = 5,
    minTransferTime = 60, # in secs
    cutoffSec = 900,
    cutoffSec = 1800,
    cutoffSec = 2700,
    cutoffSec = 3600
  )
)

current <- content(current, as = "text", encoding = "UTF-8")
write(current, file = paste0(dp_j_prefix, lsch, '.geojson'))

}

```


```{r}
library(tidyverse)
library(leaflet)

iso <- geojsonio::geojson_read("C:/geojson/ Changi-Terminal-1 .geojson",
  what = "sp")

pal=c('cyan','gold','tomato','red')

leaflet(iso) %>%
    setView(lng = 103.8198, lat = 1.3521, zoom = 11) %>%
  addProviderTiles(providers$CartoDB.DarkMatter,
                   options = providerTileOptions(opacity = 0.8))%>%  
  addPolygons(stroke = TRUE, weight=0.5,
              smoothFactor = 0.3, color="black",
              fillOpacity = 0.1,fillColor =pal ) %>%
  addLegend(position="bottomleft",colors=rev(c("lightskyblue","greenyellow","gold","tomato")),
            labels=rev(c("60 min","45 min",
                     "30 min","15 min")),
            opacity = 0.6,
            title="Travel Time with Public Transport")
```



saves the isochrone generation for each JC as .rds in data/geojson/
Only run this code chunk if you want to generate the .rds files 
```{r}
for (i in 1:19){
  lsch = jc@data[i,'SCHOOL']
  print(lsch)
  lat = jc@coords[i,2]
  long = jc@coords[i,1]
  print(lat)
  print(long)
  
  get_geojson(lat, long, lsch)
  sp = geojsonio::geojson_read(paste0(dp_j_prefix, lsch, '.geojson'), what = "sp")
  proj4string(sp) = proj4string(hdb)
  res = colSums(gContains(sp, hdb, byid = TRUE))
  print(res)
  res = tbl_df(res)
  colnames(res) = 'blocks'
  sp@data = bind_cols(sp@data, res)
  saveRDS(sp, file = paste0(dp_j_prefix, lsch, '.rds'))
}
```


# Generate distance matrix
Get_dist function to get the data information of a trip with the fastest route.
generate_dist function to generate the distance matrix and duration from all the residential data to each school.
```{r}
#Getting the data of a trip
get_dist = function(fromLat, fromLong, toLat, toLong){
    current <- GET(
      "http://localhost:8080/otp/routers/default/plan",
      query = list(
        fromPlace = paste(fromLat,fromLong,sep = ","), # latlong of place
        toPlace = paste(toLat,toLong,sep = ","),
        mode = "WALK,TRANSIT", # modes we want the route planner to use
        date = "05-11-2020",
        time= "07:00am",
        maxWalkDistance = 1600, # in metres
        cutoffSec = 900,
        cutoffSec = 1800,
        cutoffSec = 2700,
        cutoffSec = 3600
      )
    )

    if (length(content(current)[["plan"]][["itineraries"]][[1]]) == 0){
      return(NULL)
    }else{
      return(content(current)[["plan"]][["itineraries"]][[1]])
    }
    
}
#Generating the dist and duration from all residential HDB and storing it for each school
generate_dist <-function(hdb, destLat, destLong, schName){
  result = data.frame(matrix(ncol = 6, nrow= 0))
  colnames(result) = c('address', 'destination', 'latitude', 'longitude', 'duration', 'distance')
  
  for(i in 1: length(hdb@coords[,1])){
    lat = as.double(hdb@coords[i,]['LATITUDE'])
    long = as.double(hdb@coords[i,]['LONGITUDE'])
    address = hdb@data[i,]$ADDRESS
      info = get_dist(lat, long, destLat, destLong)
      if (is.null(info)){
        next()
      }
      total = 0
      for (j in 1:length(info$legs)){
        total = total + info$legs[[j]]$distance
      }
      
      dist = total/1000 #convert to km
      dur = info$duration/60
      result[nrow(result)+1,] = list(address, schName, lat, long, dur, dist)
      print(result)
      
  }
  return(result)
}
```

Run this code to generate the .rds files (distancematrix)
```{r}
  x=1 #input x
  schName = jc@data[x,"SCHOOL"]
  print(schName)
  schLat = jc@coords[x,2]
  schLong =  jc@coords[x,1]
  result=generate_dist(hdb, schLat, schLong, schName)
  saveRDS(result, file = paste0(dp_m_prefix, schName, '.rds'))
```


# Measure accessibility with Hansen

Hansen function
```{r}
apply_hansen = function(res){
  result = res %>% mutate(demand =100)
  durationMatrix = result %>% dplyr::select('duration')
  acc_hansen <- data.frame(ac(result$demand,
                              c(10), 
                              durationMatrix,
                              power = 2, 
                              family = "Hansen"))
  result_duration = result
  result_duration$durationHansen = acc_hansen[,1]
  result_duration$durationHansen[is.na(result_duration$durationHansen)] = 0
  
  
  distanceMatrix = result %>% dplyr::select('distance')
  acc_hansen <- data.frame(ac(result$demand,
                              c(10), 
                              distanceMatrix,
                              power =2, 
                              family = "Hansen"))
  result_final = result_duration
  result_final$distanceHansen = acc_hansen[,1]
  result_final$distanceHansen[is.na(result_final$distanceHansen)] = 0
  return (result_final)
}
```

Hansen Generation for each school distance matrix
```{r}
for (x in 1:19){
  schName = jc@data[x,'SCHOOL']
  print(schName)
  res = readRDS(paste0(dp_m_prefix, '/',schName,'.rds'))
  result_acc = apply_hansen(res)
  
  result_acc_sf <- st_as_sf(result_acc, 
  coords = c('longitude', 'latitude'),
  crs = "+init=epsg:3414")

  result_acc_sp <- sf:::as_Spatial(result_acc_sf)
  
  saveRDS(result_acc_sp, paste0(dp_h_prefix, '/',schName,'.rds'))
}
```


# Measure accessibility with SAM
SAM function
```{r}
apply_sam = function(res){
  result = res %>% mutate(demand =100)
  durationMatrix = result %>% dplyr::select('duration')
  acc_sam <- data.frame(ac(result$demand,
                              c(10), 
                              durationMatrix,
                              power = 2, 
                              family = "SAM"))
  result_duration = result
  result_duration$durationSam = acc_sam[,1]
  result_duration$durationSam[is.na(result_duration$durationSam)] = 0
  
  
  distanceMatrix = result %>% dplyr::select('distance')
  acc_sam <- data.frame(ac(result$demand,
                              c(10), 
                              distanceMatrix,
                              power =2, 
                              family = "SAM"))
  result_final = result_duration
  result_final$distanceSam = acc_sam[,1]
  result_final$distanceSam[is.na(result_final$distanceSam)] = 0
  return (result_final)
}
```

SAM Generation for each school distance matrix
```{r}
for (x in 1:19){
  schName = jc@data[x,'SCHOOL']
  print(schName)
  res = readRDS(paste0(dp_m_prefix, '/',schName,'.rds'))
  result_acc = apply_sam(res)
  
  result_acc_sf <- st_as_sf(result_acc, 
  coords = c('longitude', 'latitude'),
  crs = "+init=epsg:3414")

  result_acc_sp <- sf:::as_Spatial(result_acc_sf)
  
  saveRDS(result_acc_sp, paste0(dp_s_prefix, '/',schName,'.rds'))
}
```



